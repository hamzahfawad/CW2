import csv
import shelve

# Stores member data in a csv file
members_file = "membership data.csv"

# Stores leagues in a shelve database file
LEAGUE_DB = "leagues.db"

# Valid skill levels in the club
player_skill_level = ["beginner", "improver", "intermediate", "advanced", "club"]

# League skill caps (beginners cannot join leagues; club too good)
league_level = ["improver", "intermediate", "advanced"]


# Loads member data from the csv file
def load_members():
    """Load membership data from the CSV and standardise internal keys."""
    members = []
    try:
        with open(members_file, newline="") as f:
            reader = csv.DictReader(f)

            for row in reader:
                mem_no = (row.get("Membership Number") or row.get("membership_number") or "").strip()
                first = (row.get("First Name") or row.get("first_name") or "").strip()
                surname = (row.get("Surname") or row.get("surname") or "").strip()
                skill_raw = (row.get("Skill Level") or row.get("skill") or "").strip().lower()
                credit_raw = (row.get("Credit") or row.get("credit") or "0").strip()
                league_raw = (row.get("League") or row.get("league") or "No").strip()

                try:
                    credit_val = float(credit_raw)
                except ValueError:
                    credit_val = 0.0

                # Convert Yes/No -> internal league flag
                if league_raw.lower() in ["no", "none", ""]:
                    league_val = "None"
                elif league_raw.lower() == "yes":
                    league_val = "Yes"
                else:
                    league_val = league_raw

                members.append({
                    "membership_number": mem_no,
                    "first_name": first,
                    "surname": surname,
                    "skill": skill_raw,
                    "credit": float(credit_val),
                    "league": league_val
                })
    except FileNotFoundError:
        pass

    return members


# Saves the list of members back to the csv file.
def save_members(members):
    """Save member data back to the CSV."""
    with open(members_file, "w", newline="") as f:
        fieldnames = ["Membership Number", "First Name", "Surname", "Skill Level", "Credit", "League"]
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()

        for m in members:
            league_out = "No" if m.get("league", "None") in ["None", "", None] else "Yes"

            writer.writerow({
                "Membership Number": m.get("membership_number", ""),
                "First Name": m.get("first_name", ""),
                "Surname": m.get("surname", ""),
                "Skill Level": (m.get("skill", "") or "").capitalize(),
                "Credit": m.get("credit", 0),
                "League": league_out
            })


# Adding a new member
def add_member():
    members = load_members()

    # Checks that the membership number is unique
    while True:
        number = input("Membership number: ").strip()
        exists = False
        for x in members:
            if x["membership_number"] == number:
                exists = True
        if exists:
            print("Membership number already exists.")
        else:
            break

    first = input("First name: ").strip()
    surname = input("Surname: ").strip()

    # Validates the skill level
    while True:
        skill = input("Skill level: ").lower()
        if skill in player_skill_level:
            break
        print("Invalid skill level.")

    # Validates the players starting credit
    while True:
        try:
            credit = float(input("Starting credit: "))
            if credit >= 0:
                break
        except ValueError:
            pass
        print("Invalid credit.")

    # Adds a member to list
    members.append({
        "membership_number": number,
        "first_name": first,
        "surname": surname,
        "skill": skill,
        "credit": credit,
        "league": "None"
    })

    save_members(members)
    print("Member added.")


# Deletes a member
def delete_member():
    members = load_members()
    number = input("Membership number to delete: ").strip()

    for i, m in enumerate(members):
        if m["membership_number"] == number:
            if m["credit"] > 0:
                print(f"Credit to return: {m['credit']}")
            del members[i]
            save_members(members)
            print("Member deleted.")
            return

    print("Member not found.")


# Edits a member 
def edit_member():
    members = load_members()
    number = input("Membership number to edit: ").strip()

    for m in members:
        if m["membership_number"] == number:
            new_first = input(f"First name ({m['first_name']}): ").strip()
            new_surname = input(f"Surname ({m['surname']}): ").strip()

            while True:
                new_skill = input(f"Skill level ({m['skill']}): ").strip().lower()
                if new_skill == "":
                    new_skill = m["skill"]
                    break
                if new_skill in player_skill_level:
                    break
                print("Invalid skill level.")

            while True:
                new_credit = input(f"Credit ({m['credit']}): ").strip()
                if new_credit == "":
                    credit_val = m["credit"]
                    break
                try:
                    credit_val = float(new_credit)
                    if credit_val >= 0:
                        break
                except ValueError:
                    pass
                print("Invalid credit.")

            if new_first != "":
                m["first_name"] = new_first
            if new_surname != "":
                m["surname"] = new_surname
            m["skill"] = new_skill
            m["credit"] = credit_val

            save_members(members)
            print("Member updated.")
            return

    print("Member not found.")


# Views members
def view_members():
    members = load_members()
    for m in members:
        print(m)


# Saves a league in the shelve database
def save_league(league):
    with shelve.open(LEAGUE_DB) as db:
        db[league["name"]] = league


# Loads a league from the shelve database
def load_league(name):
    with shelve.open(LEAGUE_DB) as db:
        return db.get(name, None)


# Lists saved leagues
def list_leagues():
    with shelve.open(LEAGUE_DB) as db:
        return list(db.keys())


# Makes a safe snapshot of the league table
def clone_table(table_dict):
    snapshot = {}
    for num, row in table_dict.items():
        snapshot[num] = {
            "player": row["player"].copy(),
            "points": row["points"],
            "for": row["for"],
            "against": row["against"]
        }
    return snapshot


# Displays the league table in order after it has been sorted
def display_table(league):
    table = list(league["table"].values())
    table.sort(
        key=lambda x: (
            x["points"],
            x["for"] - x["against"],
            x["for"]
        ),
        reverse=True
    )

    print("\nLeague Table")
    for i, row in enumerate(table, 1):
        p = row["player"]
        diff = row["for"] - row["against"]
        print(i, p["first_name"], p["surname"], row["points"], row["for"], row["against"], diff)


# Creates a new league and adds players
def create_league():
    members = load_members()
    name = input("League name: ").strip()

    while True:
        skill_cap = input("League skill level: ").lower()
        if skill_cap in league_level:
            break
        print("Invalid league skill.")

    while True:
        try:
            fee = float(input("Entry fee: "))
            if fee >= 0:
                break
        except ValueError:
            pass
        print("Invalid fee.")

    while True:
        try:
            num = int(input("Number of players (4–10): "))
            if 4 <= num <= 10:
                break
        except ValueError:
            pass
        print("Invalid number of players.")

    league = {
        "name": name,
        "skill_cap": skill_cap,
        "fee": fee,
        "players": [],
        "fixtures": [],
        "table": {},
        # persistence + historic rounds
        "results": [],
        "history": [],
        "current_round": 0,
        "completed": False
    }

    # Allowed skills 
    allowed_skills = ["beginner", "improver", "intermediate", "advanced"]
    allowed_skills = allowed_skills[:allowed_skills.index(skill_cap) + 1]

    while len(league["players"]) < num:
        number = input("Membership number: ").strip()
        for x in members:
            if x["membership_number"] == number:
                
                x["skill"] = x["skill"].strip().lower()
                  
                if x["league"] != "None":
                    print("Already in a league.")
                elif x["skill"] not in allowed_skills:
                    print("Skill not allowed.")
                elif x["credit"] < fee:
                    print("Not enough credit.")
                else:
                    x["credit"] -= fee
                    x["league"] = name
                    league["players"].append(x)
                break
        else:
            print("Member not found.")

    save_members(members)
    generate_fixtures(league)
    save_league(league)
    print("League created.")
    return league


# Checks if a badminton score is valid
def valid_score(a, b):
    """Valid score rules from the coursework (max 30, only draw is 30-30)."""
    if a < 0 or b < 0 or a > 30 or b > 30:
        return False
    if a == 30 and b == 30:
        return True
    if a == b:
        return False
    if (a >= 21 or b >= 21) and abs(a - b) >= 2:
        return True
    return False


# Updates the league table after a match
def update_table(league, p1, p2, s1, s2):
    league["table"][p1["membership_number"]]["for"] += s1
    league["table"][p1["membership_number"]]["against"] += s2
    league["table"][p2["membership_number"]]["for"] += s2
    league["table"][p2["membership_number"]]["against"] += s1

    if s1 > s2:
        league["table"][p1["membership_number"]]["points"] += 2
    elif s2 > s1:
        league["table"][p2["membership_number"]]["points"] += 2
    else:
        league["table"][p1["membership_number"]]["points"] += 1
        league["table"][p2["membership_number"]]["points"] += 1


def export_final_table_csv(league):
    """Mandatory: save the final league table as a CSV file."""
    filename = f"{league['name']}_final_table.csv"

    table_rows = list(league["table"].values())
    table_rows.sort(
        key=lambda x: (x["points"], x["for"] - x["against"], x["for"]),
        reverse=True
    )

    with open(filename, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["Pos", "MembershipNo", "FirstName", "Surname", "Points", "For", "Against", "Diff"])
        for i, row in enumerate(table_rows, 1):
            p = row["player"]
            diff = row["for"] - row["against"]
            writer.writerow([i, p["membership_number"], p["first_name"], p["surname"],
                             row["points"], row["for"], row["against"], diff])

    league["final_csv"] = filename
    print(f"Final league table saved to: {filename}")


def award_prizes_and_reset(league):
    """Pay prize money (50/35/15) and reset all players' league indicator."""
    table_rows = list(league["table"].values())
    table_rows.sort(
        key=lambda x: (x["points"], x["for"] - x["against"], x["for"]),
        reverse=True
    )

    if len(table_rows) < 3:
        print("Not enough players to award prizes.")
        return

    pot = league["fee"] * len(league["players"])
    shares = [0.50, 0.35, 0.15]

    members = load_members()

    # Pay top 3
    for idx in range(3):
        winner_player = table_rows[idx]["player"]
        prize = pot * shares[idx]
        for m in members:
            if m["membership_number"] == winner_player["membership_number"]:
                m["credit"] += prize
                break

    # Reset league flag for all participants
    for p in league["players"]:
        for m in members:
            if m["membership_number"] == p["membership_number"]:
                m["league"] = "None"
                break

    save_members(members)
    print("Prize money paid and players reset to league=None.")


def finalise_league(league):
    """Run at end of league: export final CSV, award prizes, mark completed, save."""
    export_final_table_csv(league)
    award_prizes_and_reset(league)
    league["completed"] = True
    save_league(league)


# Generates round robin fixtures
def generate_fixtures(league):
    players = league["players"][:]

    # Adds dummy player if there is an odd number of players
    if len(players) % 2 != 0:
        players.append(None)

    rounds = []
    for _ in range(len(players) - 1):
        matches = []
        for i in range(len(players) // 2):
            if players[i] and players[-i - 1]:
                matches.append((players[i], players[-i - 1]))
        rounds.append(matches)
        players = [players[0]] + [players[-1]] + players[1:-1]

    league["fixtures"] = rounds

    # Initialise league table
    for p in league["players"]:
        league["table"][p["membership_number"]] = {
            "player": p,
            "points": 0,
            "for": 0,
            "against": 0
        }


# Enters scores round by round and updates the table
def enter_round_scores(league):
    start_round = league.get("current_round", 0)

    for rnd in range(start_round, len(league["fixtures"])):
        matches = league["fixtures"][rnd]
        print(f"\nRound {rnd + 1}")

        round_results = []

        for p1, p2 in matches:
            while True:
                try:
                    s1 = int(input(f"{p1['first_name']} score: "))
                    s2 = int(input(f"{p2['first_name']} score: "))
                    if valid_score(s1, s2):
                        update_table(league, p1, p2, s1, s2)

                        round_results.append({
                            "p1_num": p1["membership_number"],
                            "p2_num": p2["membership_number"],
                            "p1_name": p1["first_name"],
                            "p2_name": p2["first_name"],
                            "s1": s1,
                            "s2": s2
                        })
                        break
                except ValueError:
                    pass
                print("Invalid score.")

        league["results"].append(round_results)
        league["history"].append({
            "round": rnd + 1,
            "results": round_results,
            "table": clone_table(league["table"])
        })

        league["current_round"] = rnd + 1
        save_league(league)

        display_table(league)

    if league.get("current_round", 0) >= len(league.get("fixtures", [])) and not league.get("completed", False):
        print("\nAll rounds completed.")
        finalise_league(league)


def show_past_round():
    """Historic Data: show results + league table after a specified round."""
    name = input("League name: ").strip()
    league = load_league(name)
    if not league:
        print("League not found.")
        return

    history = league.get("history", [])
    if not history:
        print("No rounds have been saved for this league yet.")
        return

    try:
        r = int(input(f"Round number (1–{len(history)}): ").strip())
    except ValueError:
        print("Invalid round number.")
        return

    if r < 1 or r > len(history):
        print("Round not found.")
        return

    snap = history[r - 1]
    print(f"\n{name} — Round {snap['round']} results")
    for g in snap["results"]:
        print(f"{g['p1_name']} {g['s1']} - {g['s2']} {g['p2_name']}")

    table_rows = list(snap["table"].values())
    table_rows.sort(
        key=lambda x: (x["points"], x["for"] - x["against"], x["for"]),
        reverse=True
    )

    print("\nLeague Table (after this round)")
    for i, row in enumerate(table_rows, 1):
        p = row["player"]
        diff = row["for"] - row["against"]
        print(i, p["first_name"], p["surname"], row["points"], row["for"], row["against"], diff)


def main():
    league = None

    while True:
        print("\n1. Add member")
        print("2. Delete member")
        print("3. Edit member")
        print("4. View members")
        print("5. Create league")
        print("6. Run league")
        print("7. Exit")
        print("8. Load league")
        print("9. View past round")
        print("10. List saved leagues")

        choice = input("Choice: ").strip()

        if choice == "1":
            add_member()
        elif choice == "2":
            delete_member()
        elif choice == "3":
            edit_member()
        elif choice == "4":
            view_members()
        elif choice == "5":
            league = create_league()
        elif choice == "6":
            if league:
                enter_round_scores(league)
            else:
                print("No league loaded/created.")
        elif choice == "8":
            name = input("League name to load: ").strip()
            league = load_league(name)
            if league:
                print(f"Loaded league: {name}")
                print(f"Current round: {league.get('current_round', 0)} / {len(league.get('fixtures', []))}")
            else:
                print("League not found.")
        elif choice == "9":
            show_past_round()
        elif choice == "10":
            names = list_leagues()
            if not names:
                print("No leagues saved yet.")
            else:
                print("Saved leagues:")
                for n in names:
                    print("-", n)
        elif choice == "7":
            break
        else:
            print("Invalid choice.")


if __name__ == "__main__":
    main()
